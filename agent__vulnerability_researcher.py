"""
Vulnerability Researcher using Pydantic AI

This module provides functionality to research security vulnerabilities and CVEs
for software packages and their specific versions using Pydantic AI.
"""

import os
import json
import asyncio
from typing import Dict, Any, List, Optional, Tuple, Union
from datetime import datetime
from pydantic import BaseModel, Field, validator
from pydantic_ai import Agent, RunContext
from dotenv import load_dotenv
import external_tools


from packaging import version as packaging_version # Use an alias to avoid conflict if needed
from packaging.specifiers import SpecifierSet, InvalidSpecifier


load_dotenv()

# Define structured output type for vulnerability research
class VulnerabilityInfo(BaseModel):
    """Information about a specific vulnerability."""
    cve_id: str = Field(..., description="The CVE identifier for the vulnerability")
    severity: str = Field(..., description="Severity level (Critical, High, Medium, Low)")
    description: str = Field(..., description="Detailed description of the vulnerability")
    status: str = Field(..., description="Current status of the vulnerability")
    discovered_date: str = Field(..., description="Date when the vulnerability was discovered")
    fixed_in_version: str = Field(..., description="Version where the vulnerability was fixed")
    attack_vector: str = Field(..., description="The attack vector for the vulnerability")
    references: List[str] = Field(default_factory=list, description="List of reference URLs")
    verified_affected: bool = Field(True, description="Whether the vulnerability has been verified to affect the specified version")

class SecurityAdvisory(BaseModel):
    """Information about a security advisory."""
    id: str = Field(..., description="Unique identifier for the advisory")
    title: str = Field(..., description="Title of the security advisory")
    severity: str = Field(..., description="Severity level (Critical, High, Medium, Low)")
    description: str = Field(..., description="Detailed description of the security issue")
    affected_versions: str = Field(..., description="Versions affected by the security issue")
    remediation: str = Field(..., description="Steps to remediate the security issue")
    references: List[str] = Field(default_factory=list, description="List of reference URLs")
    verified_affected: bool = Field(True, description="Whether the advisory has been verified to affect the specified version")

class VulnerabilityResearchResult(BaseModel):
    """Vulnerability research result with comprehensive security information."""
    package_name: str = Field(..., description="Name of the package researched")
    package_version: str = Field(..., description="Version of the package researched")
    scan_date: str = Field(..., description="Date when the scan was performed")
    vulnerabilities: List[VulnerabilityInfo] = Field(default_factory=list, description="List of found vulnerabilities")
    advisories: List[SecurityAdvisory] = Field(default_factory=list, description="List of found security advisories")
    error: Optional[str] = Field(None, description="Error message if research failed")

# Define dependencies for the agent
class VulnerabilityResearchDeps(BaseModel):
    """Dependencies for vulnerability research."""
    current_date: str = Field(..., description="Current date for the research")

def parse_package_info(text: str) -> Tuple[str, Optional[str]]:
    """
    Parse package name and version from input text.
    
    Args:
        text: Input text containing package information
        
    Returns:
        Tuple of (package_name, version) where version is optional
    """
    parts = text.strip().split()
    if not parts:
        return "Unknown", None
        
    package_name = parts[0]
    version = parts[1] if len(parts) > 1 else None
    
    # Handle common package name formats
    if package_name.startswith("@"):
        package_name = package_name[1:]
    if package_name.startswith("npm:"):
        package_name = package_name[4:]
    if package_name.startswith("pkg:"):
        package_name = package_name[4:]
        
    return package_name, version



def parse_json_result(result: Any) -> List[Dict[str, Any]]:
    """
    Parse JSON result from agent response.
    
    Args:
        result: Result from agent response (can be string or list)
        
    Returns:
        List of parsed dictionaries
    """
    try:
        # Print the type and sample of the result for debugging
        #print(f"Parsing result of type: {type(result)}")
        if isinstance(result, str):
            print(f"String result preview: {result[:100]}...")
        
        # If result is already a list, return it
        if isinstance(result, list):
            return result
            
        # If result is a string, try to parse it
        if isinstance(result, str):
            if result.startswith("Error:"):
                print(f"Error in agent response: {result}")
                return []
                
            try:
                # Try to find valid JSON in the string
                # Sometimes the result might have text before or after the JSON array
                import re
                json_pattern = r'\[.*\]'
                json_match = re.search(json_pattern, result, re.DOTALL)
                
                if json_match:
                    try:
                        data = json.loads(json_match.group(0))
                        if isinstance(data, list):
                            return data
                    except:
                        pass  # If this fails, fall back to normal parsing
                
                # Normal JSON parsing
                data = json.loads(result)
                if isinstance(data, list):
                    return data
                elif isinstance(data, dict):
                    return [data]
                else:
                    print(f"Unexpected result format: {type(data)}")
                    return []
            except json.JSONDecodeError as e:
                print(f"Failed to parse JSON result: {e}")
                print(f"Raw result: {result}")
                # Try to extract an array from the result if it contains one
                try:
                    import re
                    json_array_pattern = r'\[\s*\{.*?\}\s*(?:,\s*\{.*?\}\s*)*\]'
                    match = re.search(json_array_pattern, result, re.DOTALL)
                    if match:
                        array_str = match.group(0)
                        try:
                            data = json.loads(array_str)
                            return data if isinstance(data, list) else [data]
                        except:
                            pass
                except:
                    pass
                
                # As a fallback, create a skeleton structure
                return []
                
        # If result is a dict, wrap it in a list
        if isinstance(result, dict):
            return [result]
            
        print(f"Unexpected result type: {type(result)}")
        return []
        
    except Exception as e:
        print(f"Error parsing result: {e}")
        print(f"Raw result: {result}")
        return []

# Create specialized agents for different aspects of vulnerability research
cve_agent = Agent(
    "google-gla:gemini-2.0-flash",
    deps_type=VulnerabilityResearchDeps,
    result_type=List[VulnerabilityInfo],
    retries=5,  # Increase retries to handle validation failures
    system_prompt="""
    You are a specialized CVE researcher with expertise in identifying security vulnerabilities.
    
    Your task is to thoroughly research and document security vulnerabilities for the specified software package.
    You should be comprehensive and include ALL known vulnerabilities that exist.
    
    When researching vulnerabilities:
    1. Search for CVEs affecting the specified package
    2. Find detailed information about each vulnerability
    3. Provide comprehensive vulnerability details
    
    Focus on:
    - Finding all relevant CVEs (e.g., CVE-YYYY-NNNNN format)
    - Detailed vulnerability descriptions
    - Attack vectors and impact 
    - Severity ratings
    - Fixed versions information
    - References and sources
    
    You MUST follow the required output format:
    - Every CVE ID must be in the format "CVE-YYYY-NNNNN"
    - Severity must be one of: "Critical", "High", "Medium", "Low"
    - All fields must be properly filled in
    
    IMPORTANT: Your response must adhere to strict validation rules.
    """
)

@cve_agent.result_validator
def validate_cve_results(ctx: RunContext[VulnerabilityResearchDeps], result: List[VulnerabilityInfo]) -> List[VulnerabilityInfo]:
    """Validate the CVE results."""
    # The validator automatically runs when the agent responds
    # Validation failures will cause the agent to retry
    return result

version_verifier_agent = Agent(
    "google-gla:gemini-2.0-flash",
    deps_type=VulnerabilityResearchDeps,
    result_type=List[VulnerabilityInfo],
    retries=3,
    system_prompt="""
    You are a specialized version verification researcher. Your task is to:
    1. Verify if each CVE affects the specified version
    2. Check if vulnerabilities are fixed in earlier versions
    3. Confirm current status of vulnerabilities
    
    Focus on:
    - Accurate version comparison
    - Fix verification
    - Current vulnerability status
    - Version compatibility
    
    IMPORTANT: Always return a valid JSON array, even if empty.
    """
)

advisory_agent = Agent(
    "google-gla:gemini-2.0-flash",
    deps_type=VulnerabilityResearchDeps,
    result_type=List[SecurityAdvisory],
    retries=5,  # Increase retries to handle validation failures
    system_prompt="""
    You are a specialized security advisory researcher. Your task is to:
    1. Find security advisories from official sources
    2. Identify common misconfigurations
    3. Find security best practices
    4. Research known security issues without CVE identifiers
    
    Focus on:
    - Official security advisories (like GitHub Security Advisories with IDs like "GHSA-xxxx-xxxx-xxxx")
    - Common misconfigurations
    - Security best practices
    - Non-CVE security issues
    - Remediation steps
    
    You MUST follow the required output format:
    - Every advisory must have a unique ID (e.g., "GHSA-xxxx-xxxx-xxxx" or similar)
    - The title must be descriptive and meaningful (not generic)
    - Severity must be one of: "Critical", "High", "Medium", "Low"
    - All fields must be properly filled in
    
    IMPORTANT: Your response must adhere to strict validation rules.
    """
)

@advisory_agent.result_validator
def validate_advisory_results(ctx: RunContext[VulnerabilityResearchDeps], result: List[SecurityAdvisory]) -> List[SecurityAdvisory]:
    """Validate the advisory results."""
    # The validator automatically runs when the agent responds
    # Validation failures will cause the agent to retry
    return result

github_agent = Agent(
    "google-gla:gemini-2.0-flash",
    deps_type=VulnerabilityResearchDeps,
    result_type=List[SecurityAdvisory],
    retries=5,  # Increase retries to handle validation failures
    system_prompt="""
    You are a specialized GitHub security researcher. Your task is to:
    1. Find GitHub Security Advisories (GHSA)
    2. Research security-related issues
    3. Find security discussions
    4. Identify security-related pull requests
    
    Focus on:
    - GitHub Security Advisories (with IDs like "GHSA-xxxx-xxxx-xxxx")
    - Security-related issues
    - Security discussions
    - Security-related PRs
    - Community security concerns
    
    You MUST follow the required output format:
    - Every advisory must have a unique ID (e.g., "GHSA-xxxx-xxxx-xxxx")
    - The title must be descriptive and meaningful (not generic)
    - Severity must be one of: "Critical", "High", "Medium", "Low"
    - All fields must be properly filled in
    
    IMPORTANT: Your response must adhere to strict validation rules.
    """
)

@github_agent.result_validator
def validate_github_results(ctx: RunContext[VulnerabilityResearchDeps], result: List[SecurityAdvisory]) -> List[SecurityAdvisory]:
    """Validate the GitHub security advisory results."""
    # The validator automatically runs when the agent responds
    # Validation failures will cause the agent to retry
    return result

@cve_agent.tool
def search_cves(ctx: RunContext[VulnerabilityResearchDeps], package_name: str, package_version: Optional[str] = None) -> str:
    """
    Search for CVEs affecting a specific package.
    
    Args:
        ctx: Run context with dependencies
        package_name: Name of the package to search for
        package_version: Optional specific version to search for
    
    Returns:
        JSON string containing CVE information
    """
    prompt = f"""
    I need you to perform a comprehensive search for security vulnerabilities and CVEs affecting the {package_name} package {package_version if package_version else ""}.
    
    I'm specifically interested in the following information:
    
    1. Well-known vulnerabilities for this package
    2. Any CVEs (Common Vulnerabilities and Exposures) that have been reported
    3. Severity information for each vulnerability
    4. The version(s) where vulnerabilities were fixed
    
    Your response must be structured as a valid JSON array containing objects with exactly these field names:
    
    - cve_id: Must be in format "CVE-YYYY-NNNNN" (e.g., "CVE-2021-44228")
    - severity: Must be one of "Critical", "High", "Medium", or "Low"
    - description: Detailed explanation of the vulnerability
    - status: Current status (usually "Fixed" if it has a fix)
    - discovered_date: When it was found (e.g., "December 9, 2021")
    - fixed_in_version: Version number where the fix was implemented
    - attack_vector: How the vulnerability is exploited (e.g., "Remote")
    - references: Array of URLs to official sources
    - verified_affected: Boolean indicating if the specified version is affected
    
    IMPORTANT: Be specific with version numbers. If you find a significant vulnerability, ensure all details are accurate, especially the CVE ID and fixed version information.
    """
    
    result = external_tools.search_web(prompt)
    
    # Convert the data to a string if it's not already
    if result.status == "success":
        if isinstance(result.data, dict):
            return json.dumps(result.data)
        if isinstance(result.data, str):
            return result.data
        return json.dumps([])
    else:
        return f"Error: {result.error}"

@version_verifier_agent.tool
def verify_vulnerabilities(ctx: RunContext[VulnerabilityResearchDeps], package_name: str, package_version: str, vulnerabilities: List[Dict[str, Any]]) -> str:
    """
    Verify if vulnerabilities affect the specified version.
    
    Args:
        ctx: Run context with dependencies
        package_name: Name of the package
        package_version: Version to check
        vulnerabilities: List of vulnerabilities to verify
    
    Returns:
        JSON string containing verified vulnerabilities
    """
    prompt = f"""
    Verify if each of these vulnerabilities affects {package_name} version {package_version}:
    
    {json.dumps(vulnerabilities, indent=2)}
    
    For each vulnerability:
    1. Check if it affects version {package_version}
    2. Verify if it's fixed in an earlier version
    3. Confirm current status
    4. Update the verified_affected field
    
    Return the same JSON array with updated verified_affected fields.
    If a vulnerability is verified to not affect the version, set verified_affected to false.
    
    IMPORTANT: Always return a valid JSON array, even if empty.
    """
    
    result = external_tools.search_web(prompt)
    if result.status == "success":
        # Handle the case where data is a dictionary
        if isinstance(result.data, dict):
            return json.dumps(result.data)
        # Handle the case where data is already a string
        if isinstance(result.data, str):
            return result.data
        # Handle any other case by converting to a string
        return json.dumps([])
    else:
        return f"Error: {result.error}"

@advisory_agent.tool
def search_security_advisories(ctx: RunContext[VulnerabilityResearchDeps], package_name: str, package_version: Optional[str] = None) -> str:
    """
    Search for security advisories, misconfigurations, and non-CVE security issues
    for a specific package and version.
    
    Args:
        ctx: Run context with dependencies
        package_name: Name of the package to search for
        package_version: Optional specific version to search for
    
    Returns:
        JSON string containing security advisories for the package
    """
    prompt = f"""
    I need you to research security advisories and non-CVE security issues for the {package_name} package {package_version if package_version else ""}.
    
    Look beyond just CVEs to find:
    
    1. GitHub Security Advisories (GHSA identifiers)
    2. Security bulletins from the project maintainers
    3. Known misconfigurations that could lead to security issues
    4. Security best practices specific to this package
    5. Documented security issues that don't have CVE identifiers
    
    Your response must be structured as a valid JSON array containing objects with exactly these field names:
    
    - id: A unique identifier (e.g., "GHSA-xxxx-xxxx-xxxx" or "SA-{package_name}-001")
    - title: Clear title describing the issue
    - severity: Must be one of "Critical", "High", "Medium", or "Low"
    - description: Detailed explanation of the security issue
    - affected_versions: Version range affected by this issue
    - remediation: Steps users should take to fix the issue
    - references: Array of URLs to official sources
    - verified_affected: Boolean indicating if the specified version is affected
    
    IMPORTANT: Be specific and accurate with all information. For each advisory, ensure it has a properly formatted unique ID and meaningful title.
    """
    
    result = external_tools.search_web(prompt)
    if result.status == "success":
        # Handle the case where data is a dictionary
        if isinstance(result.data, dict):
            return json.dumps(result.data)
        # Handle the case where data is already a string
        if isinstance(result.data, str):
            return result.data
        # Handle any other case by converting to a string
        return json.dumps([])
    else:
        return f"Error: {result.error}"

@github_agent.tool
def check_github_security_advisories(ctx: RunContext[VulnerabilityResearchDeps], package_name: str) -> str:
    """
    Check GitHub Security Advisories for the specified package.
    
    Args:
        ctx: Run context with dependencies
        package_name: Name of the package to check
    
    Returns:
        JSON string containing GitHub security advisories for the package
    """
    prompt = f"""
    I need you to specifically search for GitHub Security Advisories (GHSA) for the {package_name} package.
    
    Please:
    1. Find the main GitHub repository for {package_name}
    2. Check the "Security" tab for official GitHub Security Advisories
    3. Look for security-related issues and PRs in the repository
    4. Identify any GHSA IDs associated with this package
    
    Your response must be structured as a valid JSON array containing objects with exactly these field names:
    
    - id: Must be a GHSA ID like "GHSA-xxxx-xxxx-xxxx"
    - title: The official title of the advisory
    - severity: Must be one of "Critical", "High", "Medium", or "Low"
    - description: Full description of the security issue
    - affected_versions: Version range affected (e.g., "‚â•2.0.0, <2.15.0")
    - remediation: Official mitigation or upgrade recommendation
    - references: Array of URLs, including the GitHub advisory URL
    - verified_affected: Boolean (true if it affects most versions)
    
    IMPORTANT: Be specific and thorough. 
    """
    
    result = external_tools.search_web(prompt)
    if result.status == "success":
        # Handle the case where data is a dictionary
        if isinstance(result.data, dict):
            return json.dumps(result.data)
        # Handle the case where data is already a string
        if isinstance(result.data, str):
            return result.data
        # Handle any other case by converting to a string
        return json.dumps([])
    else:
        return f"Error: {result.error}"

@cve_agent.system_prompt
@version_verifier_agent.system_prompt
@advisory_agent.system_prompt
@github_agent.system_prompt
def add_current_date(ctx: RunContext[VulnerabilityResearchDeps]) -> str:
    """Add current date to the system prompt."""
    return f"Today's date is {ctx.deps.current_date}."


def _filter_vulns_list(
    evaluated_version: packaging_version.Version,
    vulnerabilities: List[Union[VulnerabilityInfo, Dict[str, Any]]]
) -> List[Union[VulnerabilityInfo, Dict[str, Any]]]:
    """Filters vulnerabilities based on fixed_in_version."""
    active_vulnerabilities = []
    print(f"\nFiltering {len(vulnerabilities)} vulnerabilities against version {evaluated_version}...")

    for vuln in vulnerabilities:
        # Get fields safely whether it's a dict or VulnerabilityInfo
        cve_id = vuln.cve_id if isinstance(vuln, VulnerabilityInfo) else vuln.get('cve_id', 'N/A')
        fixed_in_str = vuln.fixed_in_version if isinstance(vuln, VulnerabilityInfo) else vuln.get('fixed_in_version')
        status = vuln.status if isinstance(vuln, VulnerabilityInfo) else vuln.get('status', '').lower()

        keep_vulnerability = True # Assume keep unless proven otherwise

        # Handle status-based filtering first
        if status == 'fixed':
            # If status is explicitly "fixed", try to parse version to confirm
            if fixed_in_str and fixed_in_str.strip().lower() not in ['n/a', 'none', '']:
                fixed_in_str = fixed_in_str.strip()
                
                # Try to extract version numbers from natural language descriptions
                import re
                version_matches = re.findall(r'(\d+\.\d+\.\d+)', fixed_in_str)
                if version_matches:
                    # If we found version numbers, try to parse them
                    try:
                        # Take the first version number found
                        fixed_version = packaging_version.parse(version_matches[0])
                        
                        # Check if the description suggests it's fixed in a later version
                        if any(phrase in fixed_in_str.lower() for phrase in ['after', 'later than', 'newer than', 'fixed in a later version']):
                            if evaluated_version > fixed_version:
                                print(f"  Filtering out {cve_id}: Status is Fixed and version {evaluated_version} > {fixed_version} (fixed after {fixed_version})")
                                keep_vulnerability = False
                            else:
                                print(f"  Keeping {cve_id}: Status is Fixed but version {evaluated_version} <= {fixed_version} (fixed after {fixed_version})")
                                keep_vulnerability = True
                        else:
                            # If no "after" indication, treat as exact version
                            if evaluated_version >= fixed_version:
                                print(f"  Filtering out {cve_id}: Status is Fixed and version {evaluated_version} >= {fixed_version}")
                                keep_vulnerability = False
                            else:
                                print(f"  Keeping {cve_id}: Status is Fixed but version {evaluated_version} < {fixed_version}")
                                keep_vulnerability = True
                    except packaging_version.InvalidVersion:
                        print(f"  Keeping {cve_id}: Status is Fixed but couldn't parse version from '{fixed_in_str}'")
                        keep_vulnerability = True
                else:
                    # No version numbers found, check for natural language indicators
                    if any(phrase in fixed_in_str.lower() for phrase in ['fixed in a later version', 'fixed in newer version', 'fixed after']):
                        # If we're checking a version that's definitely newer than 1.4.5
                        if evaluated_version > packaging_version.parse('1.4.5'):
                            print(f"  Filtering out {cve_id}: Status is Fixed and version {evaluated_version} is newer than 1.4.5")
                            keep_vulnerability = False
                        else:
                            print(f"  Keeping {cve_id}: Status is Fixed but version {evaluated_version} is not newer than 1.4.5")
                            keep_vulnerability = True
                    else:
                        print(f"  Keeping {cve_id}: Status is Fixed but no clear version information found")
                        keep_vulnerability = True
            else:
                print(f"  Keeping {cve_id}: Status is Fixed but no fixed version provided")
                keep_vulnerability = True
        elif status in ['not fixed', 'undergoing analysis', 'disputed']:
            print(f"  Keeping {cve_id}: Status indicates active ({status})")
            keep_vulnerability = True
        elif not fixed_in_str or fixed_in_str.strip().lower() in ['n/a', 'none', '']:
            print(f"  Keeping {cve_id}: No fixed version provided")
            keep_vulnerability = True
        else:
            # Try to parse and compare versions for other cases
            fixed_in_str = fixed_in_str.strip()
            
            if fixed_in_str.lower().startswith('after '):
                try:
                    fixed_version = packaging_version.parse(fixed_in_str[6:].strip())
                    if evaluated_version > fixed_version:
                        print(f"  Filtering out {cve_id}: Version {evaluated_version} > {fixed_version} (After {fixed_version})")
                        keep_vulnerability = False
                    else:
                        print(f"  Keeping {cve_id}: Version {evaluated_version} <= {fixed_version} (After {fixed_version})")
                        keep_vulnerability = True
                except packaging_version.InvalidVersion:
                    print(f"  Keeping {cve_id}: Could not parse version after 'After' in '{fixed_in_str}'")
                    keep_vulnerability = True
            elif fixed_in_str.lower().startswith('before '):
                try:
                    fixed_version = packaging_version.parse(fixed_in_str[7:].strip())
                    if evaluated_version < fixed_version:
                        print(f"  Filtering out {cve_id}: Version {evaluated_version} < {fixed_version} (Before {fixed_version})")
                        keep_vulnerability = False
                    else:
                        print(f"  Keeping {cve_id}: Version {evaluated_version} >= {fixed_version} (Before {fixed_version})")
                        keep_vulnerability = True
                except packaging_version.InvalidVersion:
                    print(f"  Keeping {cve_id}: Could not parse version after 'Before' in '{fixed_in_str}'")
                    keep_vulnerability = True
            else:
                try:
                    fixed_in_version_obj = packaging_version.parse(fixed_in_str)
                    if evaluated_version >= fixed_in_version_obj:
                        print(f"  Filtering out {cve_id}: Version {evaluated_version} >= {fixed_in_version_obj}")
                        keep_vulnerability = False
                    else:
                        print(f"  Keeping {cve_id}: Version {evaluated_version} < {fixed_in_version_obj}")
                        keep_vulnerability = True
                except packaging_version.InvalidVersion:
                    print(f"  Keeping {cve_id}: Could not parse version '{fixed_in_str}'")
                    keep_vulnerability = True

        if keep_vulnerability:
            active_vulnerabilities.append(vuln)

    print(f"  Finished filtering vulnerabilities. Kept {len(active_vulnerabilities)}.")
    return active_vulnerabilities


def _filter_advisories_list(
    evaluated_version: packaging_version.Version,
    advisories: List[Union[SecurityAdvisory, Dict[str, Any]]]
) -> List[Union[SecurityAdvisory, Dict[str, Any]]]:
    """Filters advisories based on affected_versions specifier."""
    active_advisories = []
    print(f"\nFiltering {len(advisories)} advisories against version {evaluated_version}...")

    for advisory in advisories:
        # Get fields safely whether it's a dict or SecurityAdvisory
        adv_id = advisory.id if isinstance(advisory, SecurityAdvisory) else advisory.get('id', 'N/A')
        affected_spec_str = advisory.affected_versions if isinstance(advisory, SecurityAdvisory) else advisory.get('affected_versions')

        keep_advisory = False # Assume discard unless proven relevant

        if not affected_spec_str:
            print(f"  Keeping advisory {adv_id}: Missing 'affected_versions'. Assuming relevant.")
            keep_advisory = True
        elif affected_spec_str.strip().lower() == 'all':
            print(f"  Keeping advisory {adv_id}: Affects 'All' versions.")
            keep_advisory = True
        else:
            # Normalize .x to .* for SpecifierSet compatibility
            normalized_spec_str = affected_spec_str.replace('.x', '.*')
            try:
                specifier_set = SpecifierSet(normalized_spec_str, prereleases=True)
                if specifier_set.contains(evaluated_version):
                    print(f"  Keeping advisory {adv_id}: Version {evaluated_version} is within specifier '{affected_spec_str}'.")
                    keep_advisory = True
                else:
                     print(f"  Filtering out advisory {adv_id}: Version {evaluated_version} is NOT within specifier '{affected_spec_str}'.")
                     keep_advisory = False
            except InvalidSpecifier:
                print(f"  Keeping advisory {adv_id}: Invalid specifier format '{affected_spec_str}'. Assuming relevant.")
                keep_advisory = True # Keep if specifier is broken
            except Exception as e:
                 print(f"  Keeping advisory {adv_id}: Error processing specifier ({e}). Assuming relevant.")
                 keep_advisory = True # Keep on unexpected error

        if keep_advisory:
            active_advisories.append(advisory)

    print(f"  Finished filtering advisories. Kept {len(active_advisories)}.")
    return active_advisories

async def vulnerability_researcher(text_information: str) -> VulnerabilityResearchResult:
    """
    Research vulnerabilities and security advisories for a given package and optionally a specific version.
    """
    # Parse package information
    package_name, package_version_str = parse_package_info(text_information)
    print(f"Researching package: {package_name} version: {package_version_str}")

    # Parse version once at the start
    parsed_evaluated_version: Optional[packaging_version.Version] = None
    if package_version_str:
        try:
            parsed_evaluated_version = packaging_version.parse(package_version_str)
            print(f"Parsed evaluated version: {parsed_evaluated_version}")
        except packaging_version.InvalidVersion:
            print(f"Warning: Could not parse package version '{package_version_str}'. Filtering will be skipped.")
            package_version_str = f"{package_version_str} (unparseable)"
        except Exception as e:
            print(f"Warning: Error parsing package version '{package_version_str}': {e}. Filtering will be skipped.")
            package_version_str = f"{package_version_str} (parse error)"

    # Load dependencies
    current_date = datetime.now().strftime("%B %d, %Y")
    deps = VulnerabilityResearchDeps(current_date=current_date)

    try:
        # Run all searches in parallel to save time
        print("Running all searches in parallel...")
        cve_result, advisory_result, github_result = await asyncio.gather(
            cve_agent.run(text_information, deps=deps),
            advisory_agent.run(text_information, deps=deps),
            github_agent.run(text_information, deps=deps)
        )

        # Parse all results at once
        print("Parsing search results...")
        raw_vulnerabilities = parse_json_result(cve_result.data)
        advisory_data = parse_json_result(advisory_result.data)
        github_data = parse_json_result(github_result.data)

        # Combine and validate advisories
        print("Processing advisories...")
        seen_ids = set()
        raw_advisories = []
        for adv in advisory_data + github_data:
            # Skip if not a dict or SecurityAdvisory
            if not isinstance(adv, (dict, SecurityAdvisory)):
                continue

            # Get fields safely whether it's a dict or SecurityAdvisory
            adv_id = adv.id if isinstance(adv, SecurityAdvisory) else adv.get('id', 'ADV-Unknown')
            title = adv.title if isinstance(adv, SecurityAdvisory) else adv.get('title', 'Unknown Advisory')
            desc = adv.description if isinstance(adv, SecurityAdvisory) else adv.get('description', '').strip()

            if (adv_id != "ADV-Unknown" and 
                title != "Unknown Advisory" and 
                desc and 
                desc != "No description provided" and 
                not adv_id.startswith("CVE-") and 
                adv_id not in seen_ids):
                raw_advisories.append(adv)
                seen_ids.add(adv_id)

        # Filter vulnerabilities and advisories if we have a valid version
        if parsed_evaluated_version:
            print("Filtering results based on version...")
            raw_vulnerabilities = _filter_vulns_list(parsed_evaluated_version, raw_vulnerabilities)
            raw_advisories = _filter_advisories_list(parsed_evaluated_version, raw_advisories)

        # Convert to final Pydantic models
        print("Converting to final models...")
        final_vulnerabilities = []
        final_advisories = []

        for v_data in raw_vulnerabilities:
            try:
                if isinstance(v_data, dict):
                    final_vulnerabilities.append(VulnerabilityInfo(**v_data))
                elif isinstance(v_data, VulnerabilityInfo):
                    final_vulnerabilities.append(v_data)
            except Exception as e:
                print(f"Error converting vulnerability: {e}")
                if isinstance(v_data, dict):
                    print(f"Data: {v_data}")

        for a_data in raw_advisories:
            try:
                if isinstance(a_data, dict):
                    final_advisories.append(SecurityAdvisory(**a_data))
                elif isinstance(a_data, SecurityAdvisory):
                    final_advisories.append(a_data)
            except Exception as e:
                print(f"Error converting advisory: {e}")
                if isinstance(a_data, dict):
                    print(f"Data: {a_data}")

        print(f"Found {len(final_vulnerabilities)} vulnerabilities and {len(final_advisories)} advisories")

        return VulnerabilityResearchResult(
            package_name=package_name,
            package_version=package_version_str or "Unknown",
            scan_date=current_date,
            vulnerabilities=final_vulnerabilities,
            advisories=final_advisories
        )

    except Exception as e:
        error_msg = f"Error during research: {str(e)}"
        print(error_msg)
        return VulnerabilityResearchResult(
            package_name=package_name,
            package_version=package_version_str or "Unknown",
            scan_date=current_date,
            vulnerabilities=[],
            advisories=[],
            error=error_msg
        )

def print_results(result: VulnerabilityResearchResult):
    """Print results in a clean format."""
    print("\nüîç VULNERABILITY RESEARCH RESULTS:")
    print("=" * 50)
    print(f"üì¶ Package: {result.package_name}")
    print(f"üìä Version: {result.package_version}")
    print(f"üìÖ Scan Date: {result.scan_date}")
    
    if result.error:
        print(f"\n‚ö†Ô∏è Error: {result.error}")
    
    # Get all vulnerabilities
    affected_vulns = result.vulnerabilities
    
    if affected_vulns:
        print("\n‚ö†Ô∏è VULNERABILITIES FOUND:")
        for i, vuln in enumerate(affected_vulns, 1):
            print(f"\n  {i}. {vuln.cve_id} - {vuln.severity}")
            print(f"     Description: {vuln.description}")
            print(f"     Status: {vuln.status}")
            print(f"     Fixed in: {vuln.fixed_in_version}")
            print(f"     Attack Vector: {vuln.attack_vector}")
            if vuln.references:
                print("     References:")
                for ref in vuln.references:
                    print(f"       - {ref}")
    else:
        print("\n‚úÖ No vulnerabilities found affecting this version")
    
    # Get all advisories
    affected_advisories = result.advisories
    
    if affected_advisories:
        print("\nüì¢ SECURITY ADVISORIES:")
        for i, advisory in enumerate(affected_advisories, 1):
            print(f"\n  {i}. {advisory.title} - {advisory.severity}")
            print(f"     ID: {advisory.id}")
            print(f"     Description: {advisory.description}")
            print(f"     Affected Versions: {advisory.affected_versions}")
            print(f"     Remediation: {advisory.remediation}")
            if advisory.references:
                print("     References:")
                for ref in advisory.references:
                    print(f"       - {ref}")
    else:
        print("\n‚úÖ No security advisories found affecting this version")
    
    print("=" * 50)

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python agent__vulnerability_researcher.py <package_name_or_url>")
        sys.exit(1)
        
    package_input = sys.argv[1]
    
    # Run the async function using asyncio
    result = asyncio.run(vulnerability_researcher(package_input))
    print_results(result)

    # Get model data for JSON
    filtered_result = result.model_dump()
    
    # Add a timestamp to the JSON output
    filtered_result["generated_at"] = datetime.now().isoformat()
    
    import json
    with open("vulnerability_info.json", "w") as f:
        json.dump(filtered_result, f, indent=4) 